'''
case 1
1: 3, 2, 7, 2 = 14
2: 4, 6, 5, 1 = 16

2가 더 크니, 2에서 4를 빼서 1에 
1: 3, 2, 7, 2, 4 = 18
2: 6, 5, 1 = 12

1이 더 크니, 1에서 3을 빼서 2에 
1: 2, 7, 2, 4 = 15 !!!
2: 6, 5, 1, 3 = 15 !!!

------------------
case 2
1: 1, 2, 1, 2 = 6
2: 1, 10, 1, 2 = 14

2가 더 크니, 2에서 1을 빼서 1에 
1: 1, 2, 1, 2, 1 = 7
2: 10, 1, 2 = 13

2가 더 크니, 2에서 10을 빼서 1에 
1: 1, 2, 1, 2, 1, 10 = 17
2: 1, 2 = 3

1이 더 크니, 1에서 1을 빼서 2에 
1: 2, 1, 2, 1, 10 = 16
2: 1, 2, 1 = 4

1이 더 크니, 1에서 2을 빼서 2에 
1: 1, 2, 1, 10 = 14
2: 1, 2, 1, 2 = 6

1이 더 크니, 1에서 1을 빼서 2에 
1: 2, 1, 10 = 13
2: 1, 2, 1, 2, 1 = 7

1이 더 크니, 1에서 2을 빼서 2에 
1: 1, 10 = 11
2: 1, 2, 1, 2, 1, 2 = 9

1이 더 크니, 1에서 1을 빼서 2에 
1: 10 = 10 !!!
2: 1, 2, 1, 2, 1, 2, 1 = 10 !!! 
'''
from collections import deque
def solution(queue1, queue2):
    answer = 0
    
    origin_q1 = deque(queue1)
    q1 = deque(queue1)
    q2 = deque(queue2)
    
    sum1 = sum(q1)        
    sum2 = sum(q2)
    # 실패: 큐가 원상태로 돌아온다면 실패 
        # 원상태로 돌아오는 실행횟수는?: 두 큐의 길이 * 2
            # 양쪽에 삽입 삭제 연산이 일어날 수 있는 최악의(가장 장기간의) 경우는 양쪽에 번갈아 가면서 원소를 주고 받거나, 한쪽에서 연달아 모든 원소를 넘기고 난 후 다른 쪽에서 자신의 원래 원소를 모두 넘기는 경우임. 이 경우 딱 자신들의 길이만큼이며, 이 상황 후에는 각 큐가 원상태로 돌아오게 됨  
    limit = (len(q1) + len(q2)) * 2
     
    # 양 큐의 합이 홀수라면 무조건 불가 
    if (sum1 + sum2) % 2 != 0:
        return -1
    
    while True:
        # 실패 
        if answer == limit:
            answer = -1
            break
        # 성공 
        elif sum1 == sum2:
            break
        elif sum1 > sum2:
            front = q1.popleft()
            q2.append(front)
            sum1 -= front
            sum2 += front
        else:
            front = q2.popleft()
            q1.append(front)
            sum2 -= front
            sum1 += front
            
        answer += 1
        
    return answer